/***********************************************************************
   WARNING: This file generated by robots.  Do not attempt to modify.

   This API is for use with DBAssets.db
   Which contains 5 table(s).
***********************************************************************/

#include "D:\dev\snesquest\libsnes/DBAssets.h"
#include "DB.h"
#include "libutils/CheckedMemory.h"
#include "sqlite/sqlite3.h"

void dbPaletteOwnersDestroyStatements(DB_DBAssets *db);
int dbPaletteOwnersCreateTable(DB_DBAssets *db);
void dbPalettesDestroyStatements(DB_DBAssets *db);
int dbPalettesCreateTable(DB_DBAssets *db);
void dbCharacterImportDataDestroyStatements(DB_DBAssets *db);
int dbCharacterImportDataCreateTable(DB_DBAssets *db);
void dbCharacterMapsDestroyStatements(DB_DBAssets *db);
int dbCharacterMapsCreateTable(DB_DBAssets *db);
void dbCharacterEncodePaletteDestroyStatements(DB_DBAssets *db);
int dbCharacterEncodePaletteCreateTable(DB_DBAssets *db);

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
} DBPaletteOwnersStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBPalettesStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectBycharacterMapId;
   sqlite3_stmt *deleteBycharacterMapId;
} DBCharacterImportDataStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
} DBCharacterMapsStmts;

typedef struct {
   sqlite3_stmt *insert;
   sqlite3_stmt *update;
   sqlite3_stmt *selectAll;
   sqlite3_stmt *deleteAll;
   sqlite3_stmt *selectByid;
   sqlite3_stmt *deleteByid;
   sqlite3_stmt *selectBycharacterMapId;
   sqlite3_stmt *deleteBycharacterMapId;
} DBCharacterEncodePaletteStmts;

struct DB_DBAssets{
   DBBase base;
   DBPaletteOwnersStmts PaletteOwnersStmts;
   DBPalettesStmts PalettesStmts;
   DBCharacterImportDataStmts CharacterImportDataStmts;
   DBCharacterMapsStmts CharacterMapsStmts;
   DBCharacterEncodePaletteStmts CharacterEncodePaletteStmts;
};

DB_DBAssets *db_DBAssetsCreate(){
   DB_DBAssets *out = checkedCalloc(1, sizeof(DB_DBAssets));
   return out;
}

void db_DBAssetsDestroy(DB_DBAssets *self){
   dbDestroy((DBBase*)self);
   dbPaletteOwnersDestroyStatements(self);
   dbPalettesDestroyStatements(self);
   dbCharacterImportDataDestroyStatements(self);
   dbCharacterMapsDestroyStatements(self);
   dbCharacterEncodePaletteDestroyStatements(self);
   checkedFree(self);
}

int db_DBAssetsCreateTables(DB_DBAssets *self){
   int result = 0;

   if((result = dbPaletteOwnersCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbPalettesCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbCharacterImportDataCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbCharacterMapsCreateTable(self)) != DB_SUCCESS){ return result; }
   if((result = dbCharacterEncodePaletteCreateTable(self)) != DB_SUCCESS){ return result; }

   return DB_SUCCESS;
}

#define VectorTPart DBPaletteOwners
#include "libutils/Vector_Impl.h"

void dbPaletteOwnersDestroy(DBPaletteOwners *self){
}
void dbPaletteOwnersDestroyStatements(DB_DBAssets *db){
   if(db->PaletteOwnersStmts.insert){
      sqlite3_finalize(db->PaletteOwnersStmts.insert);
      db->PaletteOwnersStmts.insert = NULL;
   }
   if(db->PaletteOwnersStmts.update){
      sqlite3_finalize(db->PaletteOwnersStmts.update);
      db->PaletteOwnersStmts.update = NULL;
   }
   if(db->PaletteOwnersStmts.selectAll){
      sqlite3_finalize(db->PaletteOwnersStmts.selectAll);
      db->PaletteOwnersStmts.selectAll = NULL;
   }
   if(db->PaletteOwnersStmts.deleteAll){
      sqlite3_finalize(db->PaletteOwnersStmts.deleteAll);
      db->PaletteOwnersStmts.deleteAll = NULL;
   }
}
int dbPaletteOwnersCreateTable(DB_DBAssets *db){
   static const char *cmd = "CREATE TABLE \"PaletteOwners\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"characterMapId\" INTEGER, FOREIGN KEY (\"characterMapId\") REFERENCES \"CharacterMaps\" (\"id\") ON DELETE CASCADE));";
   return dbExecute((DBBase*)db, cmd);
}
int dbPaletteOwnersInsert(DB_DBAssets *db, const DBPaletteOwners *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"PaletteOwners\" (\"characterMapId\") VALUES (:characterMapId);";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteOwnersStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->PaletteOwnersStmts.insert, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteOwnersStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbPaletteOwnersUpdate(DB_DBAssets *db, const DBPaletteOwners *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"PaletteOwners\" SET (\"characterMapId\" = :characterMapId) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteOwnersStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->PaletteOwnersStmts.update, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->PaletteOwnersStmts.update, 2, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PaletteOwnersStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBPaletteOwners) *dbPaletteOwnersSelectAll(DB_DBAssets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"PaletteOwners\";";
   if(dbPrepareStatement((DBBase*)db, &db->PaletteOwnersStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBPaletteOwners) *out = vecCreate(DBPaletteOwners)(&dbPaletteOwnersDestroy);

   while((result = sqlite3_step(db->PaletteOwnersStmts.selectAll)) == SQLITE_ROW){
      DBPaletteOwners newObj = {0};

      newObj.id = sqlite3_column_int(db->PaletteOwnersStmts.selectAll, 0);
      newObj.characterMapId = sqlite3_column_int(db->PaletteOwnersStmts.selectAll, 1);
      
      vecPushBack(DBPaletteOwners)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBPaletteOwners)(out);
      return NULL;
   }

   return out;
}
int dbPaletteOwnersDeleteAll(DB_DBAssets *db){
return DB_SUCCESS;
}
#define VectorTPart DBPalettes
#include "libutils/Vector_Impl.h"

void dbPalettesDestroy(DBPalettes *self){
   if(self->name){
      stringDestroy(self->name);
      self->name = NULL;
   }
   if(self->colors){
      checkedFree(self->colors);
      self->colors = NULL;
   }
}
void dbPalettesDestroyStatements(DB_DBAssets *db){
   if(db->PalettesStmts.insert){
      sqlite3_finalize(db->PalettesStmts.insert);
      db->PalettesStmts.insert = NULL;
   }
   if(db->PalettesStmts.update){
      sqlite3_finalize(db->PalettesStmts.update);
      db->PalettesStmts.update = NULL;
   }
   if(db->PalettesStmts.selectAll){
      sqlite3_finalize(db->PalettesStmts.selectAll);
      db->PalettesStmts.selectAll = NULL;
   }
   if(db->PalettesStmts.deleteAll){
      sqlite3_finalize(db->PalettesStmts.deleteAll);
      db->PalettesStmts.deleteAll = NULL;
   }
   if(db->PalettesStmts.selectByid){
      sqlite3_finalize(db->PalettesStmts.selectByid);
      db->PalettesStmts.selectByid = NULL;
   }
   if(db->PalettesStmts.deleteByid){
      sqlite3_finalize(db->PalettesStmts.deleteByid);
      db->PalettesStmts.deleteByid = NULL;
   }
}
int dbPalettesCreateTable(DB_DBAssets *db){
   static const char *cmd = "CREATE TABLE \"Palettes\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"paletteOwnerId\" INTEGER, \"name\" STRING, \"colorCount\" INTEGER, \"colors\" BLOB, FOREIGN KEY (\"paletteOwnerId\") REFERENCES \"PaletteOwners\" (\"id\") ON DELETE CASCADE));";
   return dbExecute((DBBase*)db, cmd);
}
int dbPalettesInsert(DB_DBAssets *db, const DBPalettes *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"Palettes\" (\"paletteOwnerId\", \"name\", \"colorCount\", \"colors\") VALUES (:paletteOwnerId, :name, :colorCount, :colors);";
   if(dbPrepareStatement((DBBase*)db, &db->PalettesStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->PalettesStmts.insert, 1, (int)obj->paletteOwnerId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->PalettesStmts.insert, 2, c_str(obj->name), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->PalettesStmts.insert, 3, (int)obj->colorCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->PalettesStmts.insert, 4, obj->colors, obj->colorsSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PalettesStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbPalettesUpdate(DB_DBAssets *db, const DBPalettes *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"Palettes\" SET (\"paletteOwnerId\" = :paletteOwnerId, \"name\" = :name, \"colorCount\" = :colorCount, \"colors\" = :colors) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->PalettesStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->PalettesStmts.update, 1, (int)obj->paletteOwnerId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_text(db->PalettesStmts.update, 2, c_str(obj->name), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->PalettesStmts.update, 3, (int)obj->colorCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->PalettesStmts.update, 4, obj->colors, obj->colorsSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->PalettesStmts.update, 5, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PalettesStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBPalettes) *dbPalettesSelectAll(DB_DBAssets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palettes\";";
   if(dbPrepareStatement((DBBase*)db, &db->PalettesStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBPalettes) *out = vecCreate(DBPalettes)(&dbPalettesDestroy);

   while((result = sqlite3_step(db->PalettesStmts.selectAll)) == SQLITE_ROW){
      DBPalettes newObj = {0};

      newObj.id = sqlite3_column_int(db->PalettesStmts.selectAll, 0);
      newObj.paletteOwnerId = sqlite3_column_int(db->PalettesStmts.selectAll, 1);
      newObj.name = stringCreate(sqlite3_column_text(db->PalettesStmts.selectAll, 2));
      newObj.colorCount = sqlite3_column_int(db->PalettesStmts.selectAll, 3);
      newObj.colorsSize = sqlite3_column_bytes(db->PalettesStmts.selectAll, 4);
      newObj.colors = checkedCalloc(1, newObj.colorsSize);
      memcpy(newObj.colors, sqlite3_column_blob(db->PalettesStmts.selectAll, 4), newObj.colorsSize);
      
      vecPushBack(DBPalettes)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBPalettes)(out);
      return NULL;
   }

   return out;
}
DBPalettes dbPalettesSelectFirstByid(DB_DBAssets *db, int id){
   DBPalettes out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"Palettes\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->PalettesStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_int(db->PalettesStmts.selectByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->PalettesStmts.selectByid)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->PalettesStmts.selectByid, 0);
      out.paletteOwnerId = sqlite3_column_int(db->PalettesStmts.selectByid, 1);
      out.name = stringCreate(sqlite3_column_text(db->PalettesStmts.selectByid, 2));
      out.colorCount = sqlite3_column_int(db->PalettesStmts.selectByid, 3);
      out.colorsSize = sqlite3_column_bytes(db->PalettesStmts.selectByid, 4);
      out.colors = checkedCalloc(1, out.colorsSize);
      memcpy(out.colors, sqlite3_column_blob(db->PalettesStmts.selectByid, 4), out.colorsSize);
   };

   return out;
}
int dbPalettesDeleteAll(DB_DBAssets *db){
return DB_SUCCESS;
}
int dbPalettesDeleteByid(DB_DBAssets *db, int id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"Palettes\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->PalettesStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->PalettesStmts.deleteByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->PalettesStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBCharacterImportData
#include "libutils/Vector_Impl.h"

void dbCharacterImportDataDestroy(DBCharacterImportData *self){
   if(self->pixelData){
      checkedFree(self->pixelData);
      self->pixelData = NULL;
   }
   if(self->colorMapping){
      checkedFree(self->colorMapping);
      self->colorMapping = NULL;
   }
}
void dbCharacterImportDataDestroyStatements(DB_DBAssets *db){
   if(db->CharacterImportDataStmts.insert){
      sqlite3_finalize(db->CharacterImportDataStmts.insert);
      db->CharacterImportDataStmts.insert = NULL;
   }
   if(db->CharacterImportDataStmts.update){
      sqlite3_finalize(db->CharacterImportDataStmts.update);
      db->CharacterImportDataStmts.update = NULL;
   }
   if(db->CharacterImportDataStmts.selectAll){
      sqlite3_finalize(db->CharacterImportDataStmts.selectAll);
      db->CharacterImportDataStmts.selectAll = NULL;
   }
   if(db->CharacterImportDataStmts.deleteAll){
      sqlite3_finalize(db->CharacterImportDataStmts.deleteAll);
      db->CharacterImportDataStmts.deleteAll = NULL;
   }
   if(db->CharacterImportDataStmts.selectBycharacterMapId){
      sqlite3_finalize(db->CharacterImportDataStmts.selectBycharacterMapId);
      db->CharacterImportDataStmts.selectBycharacterMapId = NULL;
   }
   if(db->CharacterImportDataStmts.deleteBycharacterMapId){
      sqlite3_finalize(db->CharacterImportDataStmts.deleteBycharacterMapId);
      db->CharacterImportDataStmts.deleteBycharacterMapId = NULL;
   }
}
int dbCharacterImportDataCreateTable(DB_DBAssets *db){
   static const char *cmd = "CREATE TABLE \"CharacterImportData\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"characterMapId\" INTEGER NOT NULL, \"width\" INTEGER, \"height\" INTEGER, \"pixelData\" BLOB, \"offsetX\" INTEGER, \"offsetY\" INTEGER, \"tileCountX\" INTEGER, \"tileCountY\" INTEGER, \"colorMapping\" BLOB, FOREIGN KEY (\"characterMapId\") REFERENCES \"CharacterMaps\" (\"id\") ON DELETE CASCADE));";
   return dbExecute((DBBase*)db, cmd);
}
int dbCharacterImportDataInsert(DB_DBAssets *db, const DBCharacterImportData *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"CharacterImportData\" (\"characterMapId\", \"width\", \"height\", \"pixelData\", \"offsetX\", \"offsetY\", \"tileCountX\", \"tileCountY\", \"colorMapping\") VALUES (:characterMapId, :width, :height, :pixelData, :offsetX, :offsetY, :tileCountX, :tileCountY, :colorMapping);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 2, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 3, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterImportDataStmts.insert, 4, obj->pixelData, obj->pixelDataSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 5, (int)obj->offsetX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 6, (int)obj->offsetY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 7, (int)obj->tileCountX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.insert, 8, (int)obj->tileCountY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterImportDataStmts.insert, 9, obj->colorMapping, obj->colorMappingSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterImportDataStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbCharacterImportDataUpdate(DB_DBAssets *db, const DBCharacterImportData *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"CharacterImportData\" SET (\"characterMapId\" = :characterMapId, \"width\" = :width, \"height\" = :height, \"pixelData\" = :pixelData, \"offsetX\" = :offsetX, \"offsetY\" = :offsetY, \"tileCountX\" = :tileCountX, \"tileCountY\" = :tileCountY, \"colorMapping\" = :colorMapping) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 2, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 3, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterImportDataStmts.update, 4, obj->pixelData, obj->pixelDataSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 5, (int)obj->offsetX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 6, (int)obj->offsetY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 7, (int)obj->tileCountX);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 8, (int)obj->tileCountY);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterImportDataStmts.update, 9, obj->colorMapping, obj->colorMappingSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterImportDataStmts.update, 10, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterImportDataStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBCharacterImportData) *dbCharacterImportDataSelectAll(DB_DBAssets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterImportData\";";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBCharacterImportData) *out = vecCreate(DBCharacterImportData)(&dbCharacterImportDataDestroy);

   while((result = sqlite3_step(db->CharacterImportDataStmts.selectAll)) == SQLITE_ROW){
      DBCharacterImportData newObj = {0};

      newObj.id = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 0);
      newObj.characterMapId = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 1);
      newObj.width = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 2);
      newObj.height = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 3);
      newObj.pixelDataSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectAll, 4);
      newObj.pixelData = checkedCalloc(1, newObj.pixelDataSize);
      memcpy(newObj.pixelData, sqlite3_column_blob(db->CharacterImportDataStmts.selectAll, 4), newObj.pixelDataSize);
      newObj.offsetX = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 5);
      newObj.offsetY = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 6);
      newObj.tileCountX = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 7);
      newObj.tileCountY = sqlite3_column_int(db->CharacterImportDataStmts.selectAll, 8);
      newObj.colorMappingSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectAll, 9);
      newObj.colorMapping = checkedCalloc(1, newObj.colorMappingSize);
      memcpy(newObj.colorMapping, sqlite3_column_blob(db->CharacterImportDataStmts.selectAll, 9), newObj.colorMappingSize);
      
      vecPushBack(DBCharacterImportData)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBCharacterImportData)(out);
      return NULL;
   }

   return out;
}
DBCharacterImportData dbCharacterImportDataSelectFirstBycharacterMapId(DB_DBAssets *db, int characterMapId){
   DBCharacterImportData out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterImportData\" WHERE \"characterMapId\" = :characterMapId;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.selectBycharacterMapId, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.selectBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->CharacterImportDataStmts.selectBycharacterMapId)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 0);
      out.characterMapId = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 1);
      out.width = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 2);
      out.height = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 3);
      out.pixelDataSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectBycharacterMapId, 4);
      out.pixelData = checkedCalloc(1, out.pixelDataSize);
      memcpy(out.pixelData, sqlite3_column_blob(db->CharacterImportDataStmts.selectBycharacterMapId, 4), out.pixelDataSize);
      out.offsetX = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 5);
      out.offsetY = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 6);
      out.tileCountX = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 7);
      out.tileCountY = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 8);
      out.colorMappingSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectBycharacterMapId, 9);
      out.colorMapping = checkedCalloc(1, out.colorMappingSize);
      memcpy(out.colorMapping, sqlite3_column_blob(db->CharacterImportDataStmts.selectBycharacterMapId, 9), out.colorMappingSize);
   };

   return out;
}
vec(DBCharacterImportData) *dbCharacterImportDataSelectBycharacterMapId(DB_DBAssets *db, int characterMapId){
   int result = 0;
   vec(DBCharacterImportData) *out = NULL;
   static const char *stmt = "SELECT * FROM \"CharacterImportData\" WHERE \"characterMapId\" = :characterMapId;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.selectBycharacterMapId, stmt) != DB_SUCCESS){
      return NULL;
   }

   result = sqlite3_bind_int(db->CharacterImportDataStmts.selectBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   out = vecCreate(DBCharacterImportData)(&dbCharacterImportDataDestroy);

   while((result = sqlite3_step(db->CharacterImportDataStmts.selectBycharacterMapId)) == SQLITE_ROW){
      DBCharacterImportData newObj = {0};

      newObj.id = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 0);
      newObj.characterMapId = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 1);
      newObj.width = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 2);
      newObj.height = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 3);
      newObj.pixelDataSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectBycharacterMapId, 4);
      newObj.pixelData = checkedCalloc(1, newObj.pixelDataSize);
      memcpy(newObj.pixelData, sqlite3_column_blob(db->CharacterImportDataStmts.selectBycharacterMapId, 4), newObj.pixelDataSize);
      newObj.offsetX = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 5);
      newObj.offsetY = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 6);
      newObj.tileCountX = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 7);
      newObj.tileCountY = sqlite3_column_int(db->CharacterImportDataStmts.selectBycharacterMapId, 8);
      newObj.colorMappingSize = sqlite3_column_bytes(db->CharacterImportDataStmts.selectBycharacterMapId, 9);
      newObj.colorMapping = checkedCalloc(1, newObj.colorMappingSize);
      memcpy(newObj.colorMapping, sqlite3_column_blob(db->CharacterImportDataStmts.selectBycharacterMapId, 9), newObj.colorMappingSize);
      
      vecPushBack(DBCharacterImportData)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBCharacterImportData)(out);
      return NULL;
   }

   return out;
}
int dbCharacterImportDataDeleteAll(DB_DBAssets *db){
return DB_SUCCESS;
}
int dbCharacterImportDataDeleteBycharacterMapId(DB_DBAssets *db, int characterMapId){
   int result = 0;
   static const char *stmt = "DELETE FROM \"CharacterImportData\" WHERE (\"characterMapId\" = :characterMapId);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterImportDataStmts.deleteBycharacterMapId, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterImportDataStmts.deleteBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterImportDataStmts.deleteBycharacterMapId);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBCharacterMaps
#include "libutils/Vector_Impl.h"

void dbCharacterMapsDestroy(DBCharacterMaps *self){
   if(self->name){
      stringDestroy(self->name);
      self->name = NULL;
   }
   if(self->data){
      checkedFree(self->data);
      self->data = NULL;
   }
   if(self->tilePaletteMap){
      checkedFree(self->tilePaletteMap);
      self->tilePaletteMap = NULL;
   }
}
void dbCharacterMapsDestroyStatements(DB_DBAssets *db){
   if(db->CharacterMapsStmts.insert){
      sqlite3_finalize(db->CharacterMapsStmts.insert);
      db->CharacterMapsStmts.insert = NULL;
   }
   if(db->CharacterMapsStmts.update){
      sqlite3_finalize(db->CharacterMapsStmts.update);
      db->CharacterMapsStmts.update = NULL;
   }
   if(db->CharacterMapsStmts.selectAll){
      sqlite3_finalize(db->CharacterMapsStmts.selectAll);
      db->CharacterMapsStmts.selectAll = NULL;
   }
   if(db->CharacterMapsStmts.deleteAll){
      sqlite3_finalize(db->CharacterMapsStmts.deleteAll);
      db->CharacterMapsStmts.deleteAll = NULL;
   }
   if(db->CharacterMapsStmts.selectByid){
      sqlite3_finalize(db->CharacterMapsStmts.selectByid);
      db->CharacterMapsStmts.selectByid = NULL;
   }
   if(db->CharacterMapsStmts.deleteByid){
      sqlite3_finalize(db->CharacterMapsStmts.deleteByid);
      db->CharacterMapsStmts.deleteByid = NULL;
   }
}
int dbCharacterMapsCreateTable(DB_DBAssets *db){
   static const char *cmd = "CREATE TABLE \"CharacterMaps\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"name\" STRING, \"width\" INTEGER, \"height\" INTEGER, \"colorCount\" INTEGER, \"data\" BLOB, \"tilePaletteMap\" BLOB, \"encodePaletteCount\" INTEGER);";
   return dbExecute((DBBase*)db, cmd);
}
int dbCharacterMapsInsert(DB_DBAssets *db, const DBCharacterMaps *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"CharacterMaps\" (\"name\", \"width\", \"height\", \"colorCount\", \"data\", \"tilePaletteMap\", \"encodePaletteCount\") VALUES (:name, :width, :height, :colorCount, :data, :tilePaletteMap, :encodePaletteCount);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterMapsStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->CharacterMapsStmts.insert, 1, c_str(obj->name), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.insert, 2, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.insert, 3, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.insert, 4, (int)obj->colorCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterMapsStmts.insert, 5, obj->data, obj->dataSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterMapsStmts.insert, 6, obj->tilePaletteMap, obj->tilePaletteMapSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.insert, 7, (int)obj->encodePaletteCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterMapsStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbCharacterMapsUpdate(DB_DBAssets *db, const DBCharacterMaps *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"CharacterMaps\" SET (\"name\" = :name, \"width\" = :width, \"height\" = :height, \"colorCount\" = :colorCount, \"data\" = :data, \"tilePaletteMap\" = :tilePaletteMap, \"encodePaletteCount\" = :encodePaletteCount) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterMapsStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_text(db->CharacterMapsStmts.update, 1, c_str(obj->name), -1, NULL);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.update, 2, (int)obj->width);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.update, 3, (int)obj->height);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.update, 4, (int)obj->colorCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterMapsStmts.update, 5, obj->data, obj->dataSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_blob(db->CharacterMapsStmts.update, 6, obj->tilePaletteMap, obj->tilePaletteMapSize, SQLITE_TRANSIENT);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.update, 7, (int)obj->encodePaletteCount);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterMapsStmts.update, 8, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterMapsStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBCharacterMaps) *dbCharacterMapsSelectAll(DB_DBAssets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterMaps\";";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterMapsStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBCharacterMaps) *out = vecCreate(DBCharacterMaps)(&dbCharacterMapsDestroy);

   while((result = sqlite3_step(db->CharacterMapsStmts.selectAll)) == SQLITE_ROW){
      DBCharacterMaps newObj = {0};

      newObj.id = sqlite3_column_int(db->CharacterMapsStmts.selectAll, 0);
      newObj.name = stringCreate(sqlite3_column_text(db->CharacterMapsStmts.selectAll, 1));
      newObj.width = sqlite3_column_int(db->CharacterMapsStmts.selectAll, 2);
      newObj.height = sqlite3_column_int(db->CharacterMapsStmts.selectAll, 3);
      newObj.colorCount = sqlite3_column_int(db->CharacterMapsStmts.selectAll, 4);
      newObj.dataSize = sqlite3_column_bytes(db->CharacterMapsStmts.selectAll, 5);
      newObj.data = checkedCalloc(1, newObj.dataSize);
      memcpy(newObj.data, sqlite3_column_blob(db->CharacterMapsStmts.selectAll, 5), newObj.dataSize);
      newObj.tilePaletteMapSize = sqlite3_column_bytes(db->CharacterMapsStmts.selectAll, 6);
      newObj.tilePaletteMap = checkedCalloc(1, newObj.tilePaletteMapSize);
      memcpy(newObj.tilePaletteMap, sqlite3_column_blob(db->CharacterMapsStmts.selectAll, 6), newObj.tilePaletteMapSize);
      newObj.encodePaletteCount = sqlite3_column_int(db->CharacterMapsStmts.selectAll, 7);
      
      vecPushBack(DBCharacterMaps)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBCharacterMaps)(out);
      return NULL;
   }

   return out;
}
DBCharacterMaps dbCharacterMapsSelectFirstByid(DB_DBAssets *db, int id){
   DBCharacterMaps out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterMaps\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterMapsStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_int(db->CharacterMapsStmts.selectByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->CharacterMapsStmts.selectByid)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->CharacterMapsStmts.selectByid, 0);
      out.name = stringCreate(sqlite3_column_text(db->CharacterMapsStmts.selectByid, 1));
      out.width = sqlite3_column_int(db->CharacterMapsStmts.selectByid, 2);
      out.height = sqlite3_column_int(db->CharacterMapsStmts.selectByid, 3);
      out.colorCount = sqlite3_column_int(db->CharacterMapsStmts.selectByid, 4);
      out.dataSize = sqlite3_column_bytes(db->CharacterMapsStmts.selectByid, 5);
      out.data = checkedCalloc(1, out.dataSize);
      memcpy(out.data, sqlite3_column_blob(db->CharacterMapsStmts.selectByid, 5), out.dataSize);
      out.tilePaletteMapSize = sqlite3_column_bytes(db->CharacterMapsStmts.selectByid, 6);
      out.tilePaletteMap = checkedCalloc(1, out.tilePaletteMapSize);
      memcpy(out.tilePaletteMap, sqlite3_column_blob(db->CharacterMapsStmts.selectByid, 6), out.tilePaletteMapSize);
      out.encodePaletteCount = sqlite3_column_int(db->CharacterMapsStmts.selectByid, 7);
   };

   return out;
}
int dbCharacterMapsDeleteAll(DB_DBAssets *db){
return DB_SUCCESS;
}
int dbCharacterMapsDeleteByid(DB_DBAssets *db, int id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"CharacterMaps\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterMapsStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterMapsStmts.deleteByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterMapsStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
#define VectorTPart DBCharacterEncodePalette
#include "libutils/Vector_Impl.h"

void dbCharacterEncodePaletteDestroy(DBCharacterEncodePalette *self){
}
void dbCharacterEncodePaletteDestroyStatements(DB_DBAssets *db){
   if(db->CharacterEncodePaletteStmts.insert){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.insert);
      db->CharacterEncodePaletteStmts.insert = NULL;
   }
   if(db->CharacterEncodePaletteStmts.update){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.update);
      db->CharacterEncodePaletteStmts.update = NULL;
   }
   if(db->CharacterEncodePaletteStmts.selectAll){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.selectAll);
      db->CharacterEncodePaletteStmts.selectAll = NULL;
   }
   if(db->CharacterEncodePaletteStmts.deleteAll){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.deleteAll);
      db->CharacterEncodePaletteStmts.deleteAll = NULL;
   }
   if(db->CharacterEncodePaletteStmts.selectByid){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.selectByid);
      db->CharacterEncodePaletteStmts.selectByid = NULL;
   }
   if(db->CharacterEncodePaletteStmts.deleteByid){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.deleteByid);
      db->CharacterEncodePaletteStmts.deleteByid = NULL;
   }
   if(db->CharacterEncodePaletteStmts.selectBycharacterMapId){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.selectBycharacterMapId);
      db->CharacterEncodePaletteStmts.selectBycharacterMapId = NULL;
   }
   if(db->CharacterEncodePaletteStmts.deleteBycharacterMapId){
      sqlite3_finalize(db->CharacterEncodePaletteStmts.deleteBycharacterMapId);
      db->CharacterEncodePaletteStmts.deleteBycharacterMapId = NULL;
   }
}
int dbCharacterEncodePaletteCreateTable(DB_DBAssets *db){
   static const char *cmd = "CREATE TABLE \"CharacterEncodePalette\" (\"id\" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE, \"characterMapId\" INTEGER, \"paletteId\" INTEGER, \"index\" INTEGER, FOREIGN KEY (\"characterMapId\") REFERENCES \"CharacterMaps\" (\"id\") ON DELETE CASCADE), FOREIGN KEY (\"paletteId\") REFERENCES \"Palettes\" (\"id\") ON DELETE CASCADE));";
   return dbExecute((DBBase*)db, cmd);
}
int dbCharacterEncodePaletteInsert(DB_DBAssets *db, const DBCharacterEncodePalette *obj){
   int result = 0;
   static const char *stmt = "INSERT INTO \"CharacterEncodePalette\" (\"characterMapId\", \"paletteId\", \"index\") VALUES (:characterMapId, :paletteId, :index);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.insert, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.insert, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.insert, 2, (int)obj->paletteId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.insert, 3, (int)obj->index);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterEncodePaletteStmts.insert);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbCharacterEncodePaletteUpdate(DB_DBAssets *db, const DBCharacterEncodePalette *obj){
   int result = 0;
   static const char *stmt = "UPDATE \"CharacterEncodePalette\" SET (\"characterMapId\" = :characterMapId, \"paletteId\" = :paletteId, \"index\" = :index) WHERE (\"id\" = :id)";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.update, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //bind the values
   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.update, 1, (int)obj->characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.update, 2, (int)obj->paletteId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.update, 3, (int)obj->index);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.update, 4, (int)obj->id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterEncodePaletteStmts.update);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
vec(DBCharacterEncodePalette) *dbCharacterEncodePaletteSelectAll(DB_DBAssets *db){
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterEncodePalette\";";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.selectAll, stmt) != DB_SUCCESS){
      return NULL;
   }

   vec(DBCharacterEncodePalette) *out = vecCreate(DBCharacterEncodePalette)(&dbCharacterEncodePaletteDestroy);

   while((result = sqlite3_step(db->CharacterEncodePaletteStmts.selectAll)) == SQLITE_ROW){
      DBCharacterEncodePalette newObj = {0};

      newObj.id = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectAll, 0);
      newObj.characterMapId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectAll, 1);
      newObj.paletteId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectAll, 2);
      newObj.index = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectAll, 3);
      
      vecPushBack(DBCharacterEncodePalette)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBCharacterEncodePalette)(out);
      return NULL;
   }

   return out;
}
DBCharacterEncodePalette dbCharacterEncodePaletteSelectFirstByid(DB_DBAssets *db, int id){
   DBCharacterEncodePalette out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterEncodePalette\" WHERE \"id\" = :id;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.selectByid, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.selectByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->CharacterEncodePaletteStmts.selectByid)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectByid, 0);
      out.characterMapId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectByid, 1);
      out.paletteId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectByid, 2);
      out.index = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectByid, 3);
   };

   return out;
}
DBCharacterEncodePalette dbCharacterEncodePaletteSelectFirstBycharacterMapId(DB_DBAssets *db, int characterMapId){
   DBCharacterEncodePalette out = {0};
   int result = 0;
   static const char *stmt = "SELECT * FROM \"CharacterEncodePalette\" WHERE \"characterMapId\" = :characterMapId;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.selectBycharacterMapId, stmt) != DB_SUCCESS){
      return out;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   if((result = sqlite3_step(db->CharacterEncodePaletteStmts.selectBycharacterMapId)) == SQLITE_ROW){
      out.id = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 0);
      out.characterMapId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 1);
      out.paletteId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 2);
      out.index = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 3);
   };

   return out;
}
vec(DBCharacterEncodePalette) *dbCharacterEncodePaletteSelectBycharacterMapId(DB_DBAssets *db, int characterMapId){
   int result = 0;
   vec(DBCharacterEncodePalette) *out = NULL;
   static const char *stmt = "SELECT * FROM \"CharacterEncodePalette\" WHERE \"characterMapId\" = :characterMapId;";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.selectBycharacterMapId, stmt) != DB_SUCCESS){
      return NULL;
   }

   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return out;
   }

   out = vecCreate(DBCharacterEncodePalette)(&dbCharacterEncodePaletteDestroy);

   while((result = sqlite3_step(db->CharacterEncodePaletteStmts.selectBycharacterMapId)) == SQLITE_ROW){
      DBCharacterEncodePalette newObj = {0};

      newObj.id = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 0);
      newObj.characterMapId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 1);
      newObj.paletteId = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 2);
      newObj.index = sqlite3_column_int(db->CharacterEncodePaletteStmts.selectBycharacterMapId, 3);
      
      vecPushBack(DBCharacterEncodePalette)(out, &newObj);

   };

   if(result != SQLITE_DONE){
      vecDestroy(DBCharacterEncodePalette)(out);
      return NULL;
   }

   return out;
}
int dbCharacterEncodePaletteDeleteAll(DB_DBAssets *db){
return DB_SUCCESS;
}
int dbCharacterEncodePaletteDeleteByid(DB_DBAssets *db, int id){
   int result = 0;
   static const char *stmt = "DELETE FROM \"CharacterEncodePalette\" WHERE (\"id\" = :id);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.deleteByid, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.deleteByid, 1, (int)id);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterEncodePaletteStmts.deleteByid);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
int dbCharacterEncodePaletteDeleteBycharacterMapId(DB_DBAssets *db, int characterMapId){
   int result = 0;
   static const char *stmt = "DELETE FROM \"CharacterEncodePalette\" WHERE (\"characterMapId\" = :characterMapId);";
   if(dbPrepareStatement((DBBase*)db, &db->CharacterEncodePaletteStmts.deleteBycharacterMapId, stmt) != DB_SUCCESS){
      return DB_FAILURE;
   }

   //primary key:
   result = sqlite3_bind_int(db->CharacterEncodePaletteStmts.deleteBycharacterMapId, 1, (int)characterMapId);
   if (result != SQLITE_OK) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   //now run it
   result = sqlite3_step(db->CharacterEncodePaletteStmts.deleteBycharacterMapId);
   if (result != SQLITE_DONE) {
      stringSet(db->base.err, sqlite3_errmsg(db->base.conn));
      return DB_FAILURE;
   }

   return DB_SUCCESS;
}
